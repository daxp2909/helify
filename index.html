<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Helify — Kinetic Rehab System</title>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- PDF & Email -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #050505;
            --bg-elevated: #0a0a0a;
            --bg-card: #111111;
            --border: #222222;
            --border-hover: #333333;
            --text: #e5e5e5;
            --text-muted: #666666;
            --accent: #00ff9d;        /* Green - Success/Good */
            --accent-dim: rgba(0, 255, 157, 0.1);
            --info: #00ccff;          /* Blue - Normal/Info/Detection */
            --info-dim: rgba(0, 204, 255, 0.1);
            --warning: #ffcc00;       /* Yellow - Warning/Error */
            --warning-dim: rgba(255, 204, 0, 0.1);
            --error: #ff4444;         /* Red - Critical (kept for hyperextension) */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            line-height: 1.5;
        }

        /* Scanline Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.03;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.15),
                rgba(0,0,0,0.15) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* Vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9998;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.4) 100%);
        }

        /* App Layout */
        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header - Minimal */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(5,5,5,0.9), transparent);
            pointer-events: none;
        }

        .header > * {
            pointer-events: auto;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .brand-mark {
            width: 32px;
            height: 32px;
            border: 2px solid var(--accent);
            position: relative;
            transform: rotate(45deg);
        }

        .brand-mark::before {
            content: '';
            position: absolute;
            inset: 4px;
            background: var(--accent);
            opacity: 0.3;
        }

        .brand-text {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .brand-text span {
            color: var(--accent);
        }

        /* Main Video Area */
        .main-stage {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 80px 24px 200px;
            min-height: 100vh;
        }

        .video-frame {
            position: relative;
            width: 100%;
            max-width: 1400px;
            aspect-ratio: 16/9;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
        }

        .video-frame::before,
        .video-frame::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--accent);
            opacity: 0.5;
        }

        .video-frame::before {
            top: -1px;
            left: -1px;
            border-right: none;
            border-bottom: none;
        }

        .video-frame::after {
            bottom: -1px;
            right: -1px;
            border-left: none;
            border-top: none;
        }

        #input_video {
            display: none;
        }

        #output_canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Corner Markers */
        .corner {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid var(--accent);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .video-frame:hover .corner,
        .video-frame.has-patient .corner {
            opacity: 0.3;
        }

        .corner.tr { top: -1px; right: -1px; border-left: none; border-bottom: none; }
        .corner.bl { bottom: -1px; left: -1px; border-right: none; border-top: none; }

        /* Calibration Overlay - Camera fully visible */
        .calibration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 500;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .calibration-overlay.active {
            display: flex;
        }

        .calibration-panel {
            background: rgba(5, 5, 5, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid var(--info);
            padding: 40px 60px;
            text-align: center;
            pointer-events: auto;
            position: relative;
        }

        .calibration-title {
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 20px;
            color: var(--info);
        }

        .calibration-instruction {
            font-size: 16px;
            color: var(--text);
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .calibration-leg {
            color: var(--info);
            font-weight: 700;
        }

        .calibration-feedback {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .calibration-status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 12px 24px;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
        }

        .calibration-status.detected {
            border-color: var(--accent);
            color: var(--accent);
            background: var(--accent-dim);
        }

        .calibration-status.error {
            border-color: var(--warning);
            color: var(--warning);
            background: var(--warning-dim);
        }

        .calibration-timer {
            font-family: 'JetBrains Mono', monospace;
            font-size: 48px;
            font-weight: 700;
            color: var(--info);
            width: 80px;
        }

        .calibration-progress {
            width: 300px;
            height: 4px;
            background: var(--border);
            margin: 20px auto 0;
            position: relative;
            overflow: hidden;
        }

        .calibration-progress-bar {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.1s linear;
        }

        .calibration-hint {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 20px;
            font-family: 'JetBrains Mono', monospace;
        }

        .calibration-angle-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: var(--text-muted);
            margin-top: 10px;
        }

        .calibration-angle-display.good {
            color: var(--accent);
        }

        .calibration-angle-display.bad {
            color: var(--warning);
        }

        /* Wrong Leg Warning */
        .wrong-leg-warning {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: var(--warning-dim);
            border: 1px solid var(--warning);
            padding: 16px 32px;
            z-index: 550;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }

        .wrong-leg-warning.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .wrong-leg-warning-text {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--warning);
        }

        .wrong-leg-warning-sub {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Stability Warning */
        .stability-warning {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: var(--warning-dim);
            border: 1px solid var(--warning);
            padding: 16px 32px;
            z-index: 600;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }

        .stability-warning.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .stability-warning-text {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--warning);
        }

        /* Coaching Message - Minimal */
        .coaching-hud {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            opacity: 0;
            transition: all 0.4s;
            text-align: center;
        }

        .coaching-hud.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .coaching-text {
            font-size: 14px;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
            padding: 12px 24px;
            background: var(--bg-card);
            border: 1px solid var(--info);
            color: var(--info);
            position: relative;
        }

        .coaching-text::before {
            content: '◀';
            position: absolute;
            left: -30px;
            color: var(--info);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .coaching-hud.visible .coaching-text::before {
            opacity: 1;
        }

        .coaching-text.success { 
            color: var(--accent); 
            border-color: var(--accent);
            background: var(--accent-dim);
        }
        .coaching-text.success::before { color: var(--accent); }

        .coaching-text.warning { 
            color: var(--warning); 
            border-color: var(--warning);
            background: var(--warning-dim);
        }
        .coaching-text.warning::before { color: var(--warning); }

        /* Bottom Control Deck */
        .control-deck {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 20px 24px;
            z-index: 100;
            transform: translateY(calc(100% - 80px));
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-deck.expanded {
            transform: translateY(0);
        }

        .deck-handle {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            cursor: pointer;
        }

        .deck-handle:hover {
            background: var(--border-hover);
        }

        .deck-content {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 40px;
            align-items: center;
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Leg Toggle */
        .leg-control {
            display: flex;
            gap: 0;
        }

        .leg-btn {
            padding: 12px 24px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .leg-btn:first-child {
            border-radius: 4px 0 0 4px;
            border-right: none;
        }

        .leg-btn:last-child {
            border-radius: 0 4px 4px 0;
        }

        .leg-btn:hover {
            color: var(--text);
            border-color: var(--border-hover);
        }

        .leg-btn.active {
            background: var(--info-dim);
            color: var(--info);
            border-color: var(--info);
        }

        .leg-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Center Action */
        .center-action {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .status-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .status-display.active {
            color: var(--accent);
        }

        .status-display.active::before {
            content: '● ';
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .finish-btn {
            padding: 16px 48px;
            background: var(--accent);
            color: var(--bg);
            border: none;
            font-family: inherit;
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }

        .finish-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .finish-btn:hover::before {
            left: 100%;
        }

        .finish-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 157, 0.2);
        }

        .finish-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Toggle Data View */
        .data-toggle {
            justify-self: end;
        }

        .toggle-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toggle-btn:hover {
            border-color: var(--border-hover);
            color: var(--text);
        }

        .toggle-btn.active {
            background: var(--bg-elevated);
            color: var(--text);
            border-color: var(--info);
        }

        /* Data Panel (Slide up) */
        .data-panel {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 24px;
            z-index: 90;
            transform: translateY(100%);
            transition: transform 0.4s;
        }

        .data-panel.visible {
            transform: translateY(0);
        }

        .metrics-row {
            display: flex;
            gap: 24px;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .metric-minimal {
            text-align: center;
            padding: 16px 24px;
            border: 1px solid var(--border);
            min-width: 120px;
        }

        .metric-minimal-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .metric-minimal-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
        }

        .metric-minimal-value.accent { color: var(--accent); }
        .metric-minimal-value.info { color: var(--info); }
        .metric-minimal-value.warning { color: var(--warning); }

        .metric-minimal-sub {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 4px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Modal - Redesigned */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .modal-backdrop.visible {
            display: flex;
            opacity: 1;
        }

        .modal-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .modal-close {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 48px;
            height: 48px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        .modal-close:hover {
            border-color: var(--warning);
            color: var(--warning);
            transform: rotate(90deg);
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 32px;
            border-bottom: 1px solid var(--border);
            background: var(--bg-elevated);
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: var(--accent);
        }

        .modal-subtitle {
            color: var(--text-muted);
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
        }

        .modal-body {
            padding: 32px;
            overflow-y: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            padding: 20px;
            border: 1px solid var(--border);
            background: var(--bg);
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 32px;
            font-weight: 700;
        }

        .stat-value.accent { color: var(--accent); }
        .stat-value.info { color: var(--info); }
        .stat-value.warning { color: var(--warning); }

        .issues-section {
            border: 1px solid var(--border);
            padding: 20px;
            margin-bottom: 24px;
        }

        .issues-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 12px;
        }

        .issue-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            font-size: 14px;
        }

        .issue-item:last-child {
            border-bottom: none;
        }

        .modal-footer {
            padding: 24px 32px;
            border-top: 1px solid var(--border);
            background: var(--bg-elevated);
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-label {
            display: block;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .input-field {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--info);
        }

        .button-row {
            display: flex;
            gap: 12px;
        }

        .btn {
            flex: 1;
            padding: 14px 24px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text);
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            border-color: var(--border-hover);
            background: var(--bg);
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-text {
            text-align: center;
            margin-top: 12px;
            font-size: 13px;
            color: var(--text-muted);
            min-height: 20px;
        }

        .status-text.success { color: var(--accent); }
        .status-text.error { color: var(--warning); }

        /* Toast */
        .toast-container {
            position: fixed;
            top: 100px;
            right: 24px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .toast {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-left: 3px solid var(--info);
            padding: 16px 20px;
            min-width: 280px;
            transform: translateX(120%);
            transition: transform 0.4s;
        }

        .toast.visible {
            transform: translateX(0);
        }

        .toast.success { border-left-color: var(--accent); }
        .toast.warning { border-left-color: var(--warning); }

        .toast-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 13px;
            color: var(--text-muted);
        }

        /* Rep History in Deck */
        .rep-history-compact {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s;
        }

        .control-deck.expanded .rep-history-compact {
            max-height: 200px;
            margin-top: 20px;
            overflow-y: auto;
        }

        .rep-item-compact {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
        }

        .rep-item-compact:last-child {
            border-bottom: none;
        }

        /* Toggle Icon */
        .toggle-icon {
            width: 16px;
            height: 16px;
            position: relative;
        }

        .toggle-icon::before,
        .toggle-icon::after {
            content: '';
            position: absolute;
            background: currentColor;
            transition: transform 0.2s;
        }

        .toggle-icon::before {
            width: 100%;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .toggle-icon::after {
            width: 2px;
            height: 100%;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }

        .toggle-btn.active .toggle-icon::after {
            transform: translateX(-50%) rotate(90deg);
            opacity: 0;
        }

        /* Hidden by default - data only shows when toggled */
        .data-only-view .metric-minimal-value {
            filter: blur(8px);
            user-select: none;
        }

        .data-only-view.visible .metric-minimal-value {
            filter: none;
            user-select: auto;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div class="app">
        <!-- Header -->
        <header class="header">
            <div class="brand">
                <div class="brand-mark"></div>
                <div class="brand-text">Heli<span>fy</span></div>
            </div>
        </header>

        <!-- Main Stage -->
        <main class="main-stage">
            <div class="video-frame" id="video-frame">
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                
                <video id="input_video"></video>
                <canvas id="output_canvas" width="1280" height="720"></canvas>

                <!-- Coaching HUD -->
                <div class="coaching-hud" id="coaching-hud">
                    <div class="coaching-text" id="coaching-text">Position patient</div>
                </div>
            </div>
        </main>

        <!-- Calibration Overlay - Camera stays visible behind -->
        <div class="calibration-overlay" id="calibration-overlay">
            <div class="calibration-panel">
                <div class="calibration-title">Calibration</div>
                <div class="calibration-instruction">
                    Hold your <span class="calibration-leg" id="cal-leg">LEFT</span> leg straight<br>
                    <small style="color: var(--text-muted); font-size: 12px;">Acceptable range: 0° to 10° flexion</small>
                </div>
                <div class="calibration-feedback">
                    <div class="calibration-status" id="cal-status">Searching...</div>
                    <div class="calibration-timer" id="cal-timer">3.0</div>
                </div>
                <div class="calibration-progress">
                    <div class="calibration-progress-bar" id="cal-progress"></div>
                </div>
                <div class="calibration-hint" id="cal-hint">Position your leg in view</div>
                <div class="calibration-angle-display" id="cal-angle-display">Current: --°</div>
            </div>
        </div>

        <!-- Wrong Leg Warning -->
        <div class="wrong-leg-warning" id="wrong-leg-warning">
            <div class="wrong-leg-warning-text">⚠ Wrong Leg Detected</div>
            <div class="wrong-leg-warning-sub">System detected movement in <span id="detected-leg-name">OTHER</span> leg instead of selected <span id="selected-leg-name">LEFT</span> leg</div>
        </div>

        <!-- Stability Warning -->
        <div class="stability-warning" id="stability-warning">
            <div class="stability-warning-text">⚠ Camera Unstable</div>
        </div>

        <!-- Data Panel (Slide up) -->
        <div class="data-panel" id="data-panel">
            <div class="metrics-row">
                <div class="metric-minimal">
                    <div class="metric-minimal-label">Valid Reps</div>
                    <div class="metric-minimal-value accent" id="metric-reps">0</div>
                    <div class="metric-minimal-sub" id="metric-reps-sub">0 / 0</div>
                </div>
                <div class="metric-minimal">
                    <div class="metric-minimal-label">Flexion</div>
                    <div class="metric-minimal-value info" id="metric-angle">0°</div>
                    <div class="metric-minimal-sub">0° = straight</div>
                </div>
                <div class="metric-minimal">
                    <div class="metric-minimal-label">Hip Stability</div>
                    <div class="metric-minimal-value info" id="metric-hip">--</div>
                    <div class="metric-minimal-sub" id="metric-hip-sub">--</div>
                </div>
                <div class="metric-minimal">
                    <div class="metric-minimal-label">Smoothness</div>
                    <div class="metric-minimal-value info" id="metric-smooth">--</div>
                    <div class="metric-minimal-sub" id="metric-smooth-sub">--</div>
                </div>
                <div class="metric-minimal">
                    <div class="metric-minimal-label">Quality</div>
                    <div class="metric-minimal-value info" id="metric-quality">--</div>
                    <div class="metric-minimal-sub" id="metric-timer">Ready</div>
                </div>
            </div>
        </div>

        <!-- Control Deck -->
        <div class="control-deck" id="control-deck">
            <div class="deck-handle" onclick="toggleDeck()"></div>
            
            <div class="deck-content">
                <div class="leg-control">
                    <button class="leg-btn active" onclick="setLeg('left')" id="btn-left">Left</button>
                    <button class="leg-btn" onclick="setLeg('right')" id="btn-right">Right</button>
                </div>

                <div class="center-action">
                    <div class="status-display" id="status-display">Select leg to calibrate</div>
                    <button class="finish-btn" onclick="finishSession()" id="finish-btn" disabled>Finish Session</button>
                </div>

                <div class="data-toggle">
                    <button class="toggle-btn" onclick="toggleData()" id="data-toggle-btn">
                        <div class="toggle-icon"></div>
                        <span>Show Data</span>
                    </button>
                </div>
            </div>

            <div class="rep-history-compact" id="rep-history"></div>
        </div>
    </div>

    <!-- Report Modal -->
    <div class="modal-backdrop" id="modal-backdrop" onclick="closeModal(event)">
        <div class="modal-container">
            <button class="modal-close" onclick="closeModalDirect()">×</button>
            
            <div class="modal" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <h2 class="modal-title">Session Report</h2>
                    <div class="modal-subtitle" id="modal-subtitle">--</div>
                </div>
                
                <div class="modal-body" id="modal-body">
                    <!-- Dynamic content -->
                </div>
                
                <div class="modal-footer">
                    <div class="input-group">
                        <label class="input-label">Email Address</label>
                        <input type="email" class="input-field" id="email-input" placeholder="patient@hospital.com">
                    </div>
                    
                    <div class="button-row">
                        <button class="btn" onclick="downloadPDF()">Download PDF</button>
                        <button class="btn btn-primary" onclick="sendEmail()" id="send-btn">Send Report</button>
                    </div>
                    
                    <div class="status-text" id="status-text"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <script>
        // EmailJS Config
        const EMAILJS_CONFIG = {
            PUBLIC_KEY: 'kOK8eC78MK7kSaNWJ',
            SERVICE_ID: 'service_15agqao',
            TEMPLATE_ID: 'template_stcbsh6'
        };

        try {
            emailjs.init(EMAILJS_CONFIG.PUBLIC_KEY);
        } catch(e) {
            console.error('EmailJS init failed:', e);
        }

        // Config
        const CONFIG = {
            ROM: { 
                STAND_THRESHOLD: 15, 
                DEEP_THRESHOLD: 70, 
                MAX_SAFE: -5,
                CALIBRATION_MIN: 0,    // 0 degrees (perfectly straight)
                CALIBRATION_MAX: 10     // 5 degrees flexion (acceptable range)
            },
            SPEED: { MIN_TIME: 2.0, MAX_TIME: 6.0, OPTIMAL_MIN: 2.5, OPTIMAL_MAX: 4.0 },
            STABILITY: { 
                HIP_THRESHOLD: 0.03, 
                SMOOTHNESS_WINDOW: 10, 
                JERK_THRESHOLD: 15,
                CALIBRATION_DURATION: 3.0,
                CALIBRATION_TOLERANCE: 0.05,
                FRAME_STABILITY_THRESHOLD: 0.02
            },
            TIMEOUT: 8.0,
            SCORING: { ROM_WEIGHT: 0.40, TEMPO_WEIGHT: 0.30, CONTROL_WEIGHT: 0.30 },
            WRONG_LEG_DETECTION: {
                MOVEMENT_THRESHOLD: 15,
                CONFIRMATION_FRAMES: 8,
                COOLDOWN_MS: 3000
            }
        };

        // State - Always use user's perspective (mirror mode built-in)
        const state = {
            leg: 'left',
            // MediaPipe indices: 23=LEFT side of camera (user's RIGHT), 24=RIGHT side of camera (user's LEFT)
            // We swap them so "left" button tracks user's left leg (camera's right side)
            legIndices: { hip: 24, knee: 26, ankle: 28 }, // Default to user's left leg
            
            patientId: null,
            phase: 'STANDING',
            
            validReps: 0,
            totalReps: 0,
            
            currentRep: {
                minAngle: 180,
                maxFlexion: 0,
                startHipY: 0,
                hipVariance: 0,
                hyperextended: false,
                angleHistory: [],
                lastAngle: 180,
                lastVelocity: 0,
                maxJerk: 0
            },
            
            sumRoM: 0,
            sumDuration: 0,
            bestROM: 0,
            totalScore: 0,
            
            repLogs: [],
            issues: { incompleteROM: 0, tooFast: 0, tooSlow: 0, hyperextension: 0, hipStability: 0, jerky: 0, wrongLeg: 0 },

            // Calibration state
            isCalibrating: false,
            calibrationStartTime: 0,
            calibrationStableTime: 0,
            calibrationData: [],
            isCalibrated: false,

            // Stability monitoring
            frameHistory: [],
            lastFrameTime: 0,
            cameraStable: true,
            stabilityWarnings: 0,

            // Wrong leg detection
            wrongLegDetection: {
                selectedLegHistory: [],
                otherLegHistory: [],
                lastWarningTime: 0,
                warningShown: false
            }
        };

        let currentSessionData = null;
        let dataPanelVisible = false;
        let pose = null;
        let camera = null;

        // Init
        function init() {
            const saved = localStorage.getItem('helify_leg');
            if (saved) {
                setLeg(saved, false); // Don't trigger calibration on init
            } else {
                updateStatus('Select leg to start calibration');
            }
            
            setupMediaPipe();
        }

        function setLeg(leg, triggerCalibration = true) {
            state.leg = leg;
            localStorage.setItem('helify_leg', leg);
            
            // User's left leg = camera's right side (indices 24, 26, 28)
            // User's right leg = camera's left side (indices 23, 25, 27)
            state.legIndices = leg === 'left' ? 
                { hip: 24, knee: 26, ankle: 28 } :  // User's left leg
                { hip: 23, knee: 25, ankle: 27 };   // User's right leg
            
            document.getElementById('btn-left').classList.toggle('active', leg === 'left');
            document.getElementById('btn-right').classList.toggle('active', leg === 'right');
            
            // Reset calibration when leg changes
            state.isCalibrated = false;
            state.patientId = null;
            document.getElementById('video-frame').classList.remove('has-patient');
            document.getElementById('finish-btn').disabled = true;
            
            resetSession();
            
            if (triggerCalibration) {
                startCalibration();
            } else {
                updateStatus('Click leg button to calibrate');
            }
        }

        function startCalibration() {
            state.isCalibrating = true;
            state.calibrationStartTime = performance.now() / 1000;
            state.calibrationStableTime = 0;
            state.calibrationData = [];
            
            document.getElementById('cal-leg').textContent = state.leg.toUpperCase();
            document.getElementById('calibration-overlay').classList.add('active');
            document.getElementById('cal-status').textContent = 'Searching...';
            document.getElementById('cal-status').className = 'calibration-status';
            document.getElementById('cal-timer').textContent = CONFIG.STABILITY.CALIBRATION_DURATION.toFixed(1);
            document.getElementById('cal-progress').style.width = '0%';
            document.getElementById('cal-hint').textContent = 'Position your leg in view';
            document.getElementById('cal-angle-display').textContent = 'Current: --°';
            document.getElementById('cal-angle-display').className = 'calibration-angle-display';
            
            updateStatus('Calibrating...');
            showToast('Calibration Started', `Hold your ${state.leg} leg straight (0-10°)`, 'info');
        }

        function completeCalibration() {
            state.isCalibrating = false;
            state.isCalibrated = true;
            state.patientId = 'p1';
            
            document.getElementById('calibration-overlay').classList.remove('active');
            document.getElementById('video-frame').classList.add('has-patient');
            document.getElementById('finish-btn').disabled = false;
            
            updateStatus('Tracking active - Exercise started');
            showToast('Calibration Complete', 'Exercise tracking active', 'success');
        }

        function cancelCalibration(reason) {
            state.isCalibrating = false;
            document.getElementById('calibration-overlay').classList.remove('active');
            updateStatus('Calibration failed - Select leg again');
            showToast('Calibration Failed', reason, 'warning');
        }

        function resetSession() {
            state.phase = 'STANDING';
            state.validReps = 0;
            state.totalReps = 0;
            state.sumRoM = 0;
            state.sumDuration = 0;
            state.bestROM = 0;
            state.totalScore = 0;
            state.repLogs = [];
            state.issues = { incompleteROM: 0, tooFast: 0, tooSlow: 0, hyperextension: 0, hipStability: 0, jerky: 0, wrongLeg: 0 };
            state.wrongLegDetection = {
                selectedLegHistory: [],
                otherLegHistory: [],
                lastWarningTime: 0,
                warningShown: false
            };
            
            resetRepData();
            updateMetrics();
            renderRepHistory();
            hideWrongLegWarning();
        }

        function resetRepData() {
            state.currentRep = {
                minAngle: 180,
                maxFlexion: 0,
                startHipY: 0,
                hipVariance: 0,
                hyperextended: false,
                angleHistory: [],
                lastAngle: 180,
                lastVelocity: 0,
                maxJerk: 0
            };
        }

        // UI Controls
        function toggleDeck() {
            document.getElementById('control-deck').classList.toggle('expanded');
        }

        function toggleData() {
            dataPanelVisible = !dataPanelVisible;
            document.getElementById('data-panel').classList.toggle('visible', dataPanelVisible);
            document.getElementById('data-toggle-btn').classList.toggle('active', dataPanelVisible);
        }

        function updateStatus(text) {
            const el = document.getElementById('status-display');
            el.textContent = text;
            el.classList.toggle('active', text.includes('active') || text.includes('Calibrating'));
        }

        // MediaPipe
        function setupMediaPipe() {
            pose = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
            });

            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            pose.onResults(onResults);

            const video = document.getElementById('input_video');
            camera = new Camera(video, {
                onFrame: async () => await pose.send({image: video}),
                width: 1280,
                height: 720
            });

            camera.start();
        }

        function onResults(results) {
            const canvas = document.getElementById('output_canvas');
            const ctx = canvas.getContext('2d');

            ctx.save();
            ctx.clearRect(0, 0, 1280, 720);
            
            // Mirror the canvas so it matches user's perspective
            ctx.translate(1280, 0);
            ctx.scale(-1, 1);
            
            ctx.drawImage(results.image, 0, 0, 1280, 720);

            // Check camera stability
            checkCameraStability(results);

            if (results.poseLandmarks) {
                const idx = state.legIndices;
                const hip = results.poseLandmarks[idx.hip];
                const knee = results.poseLandmarks[idx.knee];
                const ankle = results.poseLandmarks[idx.ankle];

                // Check for wrong leg detection when calibrated
                if (state.isCalibrated && !state.isCalibrating) {
                    checkWrongLeg(results.poseLandmarks);
                }

                // Calibration mode
                if (state.isCalibrating) {
                    processCalibrationFrame(results.poseLandmarks, hip, knee, ankle);
                    drawCalibrationSkeleton(ctx, results.poseLandmarks, hip, knee, ankle);
                } 
                // Exercise mode (only after calibration)
                else if (state.isCalibrated) {
                    drawSkeleton(ctx, results.poseLandmarks);
                    processExerciseFrame(results.poseLandmarks);
                } else {
                    // Just draw skeleton without processing
                    drawSkeleton(ctx, results.poseLandmarks);
                }
            }

            ctx.restore();
        }

        // Wrong Leg Detection
        function checkWrongLeg(landmarks) {
            const now = performance.now();
            const det = state.wrongLegDetection;
            
            // Check cooldown
            if (now - det.lastWarningTime < CONFIG.WRONG_LEG_DETECTION.COOLDOWN_MS) {
                return;
            }

            const selIdx = state.legIndices;
            const selHip = landmarks[selIdx.hip];
            const selKnee = landmarks[selIdx.knee];
            const selAnkle = landmarks[selIdx.ankle];

            const otherIdx = selIdx.hip === 23 ? 
                { hip: 24, knee: 26, ankle: 28 } : 
                { hip: 23, knee: 25, ankle: 27 };
            const othHip = landmarks[otherIdx.hip];
            const othKnee = landmarks[otherIdx.knee];
            const othAnkle = landmarks[otherIdx.ankle];

            // Check visibility
            if (!selHip || !selKnee || !selAnkle || !othHip || !othKnee || !othAnkle ||
                selHip.visibility < 0.5 || selKnee.visibility < 0.5 || selAnkle.visibility < 0.5 ||
                othHip.visibility < 0.5 || othKnee.visibility < 0.5 || othAnkle.visibility < 0.5) {
                return;
            }

            const selGeoAngle = calculateAngle(selHip, selKnee, selAnkle);
            const selAnaAngle = 180 - selGeoAngle;
            
            const othGeoAngle = calculateAngle(othHip, othKnee, othAnkle);
            const othAnaAngle = 180 - othGeoAngle;

            det.selectedLegHistory.push({ angle: selAnaAngle, time: now });
            det.otherLegHistory.push({ angle: othAnaAngle, time: now });

            // Keep only last 500ms of history
            det.selectedLegHistory = det.selectedLegHistory.filter(h => now - h.time < 500);
            det.otherLegHistory = det.otherLegHistory.filter(h => now - h.time < 500);

            if (det.selectedLegHistory.length < CONFIG.WRONG_LEG_DETECTION.CONFIRMATION_FRAMES ||
                det.otherLegHistory.length < CONFIG.WRONG_LEG_DETECTION.CONFIRMATION_FRAMES) {
                return;
            }

            const selMin = Math.min(...det.selectedLegHistory.map(h => h.angle));
            const selMax = Math.max(...det.selectedLegHistory.map(h => h.angle));
            const selRange = selMax - selMin;

            const othMin = Math.min(...det.otherLegHistory.map(h => h.angle));
            const othMax = Math.max(...det.otherLegHistory.map(h => h.angle));
            const othRange = othMax - othMin;

            const otherLegMoving = othRange > CONFIG.WRONG_LEG_DETECTION.MOVEMENT_THRESHOLD;
            const selectedLegStatic = selRange < CONFIG.WRONG_LEG_DETECTION.MOVEMENT_THRESHOLD / 2;

            if (otherLegMoving && selectedLegStatic) {
                showWrongLegWarning();
                det.lastWarningTime = now;
                state.issues.wrongLeg++;
            } else {
                hideWrongLegWarning();
            }
        }

        function showWrongLegWarning() {
            const warning = document.getElementById('wrong-leg-warning');
            const detectedLeg = state.leg === 'left' ? 'RIGHT' : 'LEFT';
            
            document.getElementById('detected-leg-name').textContent = detectedLeg;
            document.getElementById('selected-leg-name').textContent = state.leg.toUpperCase();
            
            warning.classList.add('visible');
            state.wrongLegDetection.warningShown = true;
            
            showToast('Wrong Leg Detected', `Please use your ${state.leg.toUpperCase()} leg`, 'warning');
        }

        function hideWrongLegWarning() {
            const warning = document.getElementById('wrong-leg-warning');
            warning.classList.remove('visible');
            state.wrongLegDetection.warningShown = false;
        }

        // Camera Stability Check
        function checkCameraStability(results) {
            const now = performance.now();
            
            if (!results.poseLandmarks) {
                state.frameHistory.push({ stable: false, time: now });
            } else {
                // Check if landmarks are jittering
                const nose = results.poseLandmarks[0];
                const stability = checkLandmarkStability(nose);
                state.frameHistory.push({ stable: stability, time: now });
            }

            // Keep only last 30 frames (about 1 second)
            state.frameHistory = state.frameHistory.filter(f => now - f.time < 1000);

            // Calculate stability percentage
            if (state.frameHistory.length > 10) {
                const stableFrames = state.frameHistory.filter(f => f.stable).length;
                const stabilityRatio = stableFrames / state.frameHistory.length;
                
                const wasStable = state.cameraStable;
                state.cameraStable = stabilityRatio > 0.7;

                // Show warning if became unstable
                if (wasStable && !state.cameraStable) {
                    showStabilityWarning();
                }
            }
        }

        function checkLandmarkStability(landmark) {
            if (!landmark) return false;
            
            // Check if landmark confidence is good
            if (landmark.visibility < 0.5) return false;

            // Simple position check - in real implementation, compare with previous positions
            return true;
        }

        function showStabilityWarning() {
            const warning = document.getElementById('stability-warning');
            warning.classList.add('visible');
            state.stabilityWarnings++;
            
            showToast('Warning', 'Camera movement detected - Results may be affected', 'warning');
            
            setTimeout(() => {
                warning.classList.remove('visible');
            }, 3000);
        }

        // Calibration Logic
        function processCalibrationFrame(landmarks, hip, knee, ankle) {
            const now = performance.now() / 1000;
            const elapsed = now - state.calibrationStartTime;

            // Check if leg is detected
            if (!hip || !knee || !ankle || hip.visibility < 0.5 || knee.visibility < 0.5 || ankle.visibility < 0.5) {
                document.getElementById('cal-status').textContent = 'Leg not visible';
                document.getElementById('cal-status').className = 'calibration-status error';
                document.getElementById('cal-hint').textContent = 'Move back to show full leg';
                document.getElementById('cal-angle-display').textContent = 'Current: --°';
                document.getElementById('cal-angle-display').className = 'calibration-angle-display';
                state.calibrationStableTime = 0;
                updateCalibrationTimer(CONFIG.STABILITY.CALIBRATION_DURATION);
                document.getElementById('cal-progress').style.width = '0%';
                return;
            }

            // Calculate angle
            const geoAngle = calculateAngle(hip, knee, ankle);
            const anaAngle = 180 - geoAngle; // This is flexion angle (0 = straight, higher = bent)

            // Update angle display
            const angleDisplay = document.getElementById('cal-angle-display');
            angleDisplay.textContent = `Current: ${Math.round(anaAngle)}° flexion`;
            
            // Check if leg is straight within 0-5 degrees range
            // anaAngle should be between 0 and 5 (0 = perfectly straight, 5 = slightly bent)
            const isStraight = anaAngle >= CONFIG.ROM.CALIBRATION_MIN && anaAngle <= CONFIG.ROM.CALIBRATION_MAX;
            
            // Update angle display color
            if (isStraight) {
                angleDisplay.className = 'calibration-angle-display good';
            } else {
                angleDisplay.className = 'calibration-angle-display bad';
            }
            
            // Check stability (small movement allowed)
            const isStable = checkCalibrationStability(hip, knee, ankle);

            if (isStraight && isStable) {
                state.calibrationStableTime += 0.033; // Approx 30fps
                const progress = Math.min(100, (state.calibrationStableTime / CONFIG.STABILITY.CALIBRATION_DURATION) * 100);
                
                document.getElementById('cal-status').textContent = 'Position Good ✓';
                document.getElementById('cal-status').className = 'calibration-status detected';
                document.getElementById('cal-hint').textContent = 'Hold steady...';
                
                updateCalibrationTimer(Math.max(0, CONFIG.STABILITY.CALIBRATION_DURATION - state.calibrationStableTime));
                document.getElementById('cal-progress').style.width = progress + '%';

                if (state.calibrationStableTime >= CONFIG.STABILITY.CALIBRATION_DURATION) {
                    completeCalibration();
                }
            } else {
                state.calibrationStableTime = 0;
                updateCalibrationTimer(CONFIG.STABILITY.CALIBRATION_DURATION);
                document.getElementById('cal-progress').style.width = '0%';
                
                if (!isStraight) {
                    if (anaAngle < 0) {
                        // Hyperextended (negative angle)
                        document.getElementById('cal-status').textContent = 'Don\'t lock knee';
                        document.getElementById('cal-hint').textContent = `Angle: ${Math.round(anaAngle)}° (slightly bend)`;
                    } else {
                        // Too bent
                        document.getElementById('cal-status').textContent = 'Straighten more';
                        document.getElementById('cal-hint').textContent = `Angle: ${Math.round(anaAngle)}° (need 0-10°)`;
                    }
                    document.getElementById('cal-status').className = 'calibration-status error';
                } else if (!isStable) {
                    document.getElementById('cal-status').textContent = 'Too much movement';
                    document.getElementById('cal-status').className = 'calibration-status error';
                    document.getElementById('cal-hint').textContent = 'Hold still, small movements OK';
                }
            }

            // Timeout after 30 seconds
            if (elapsed > 30) {
                cancelCalibration('Timeout - Please try again');
            }
        }

        function checkCalibrationStability(hip, knee, ankle) {
            state.calibrationData.push({ hip, knee, ankle, time: performance.now() });
            
            // Keep only last 10 frames
            if (state.calibrationData.length > 10) {
                state.calibrationData.shift();
            }

            if (state.calibrationData.length < 5) return true;

            // Check movement variance (allow small movements)
            const hipVariance = calculateVariance(state.calibrationData.map(d => d.hip.x)) + 
                               calculateVariance(state.calibrationData.map(d => d.hip.y));
            const kneeVariance = calculateVariance(state.calibrationData.map(d => d.knee.x)) + 
                                calculateVariance(state.calibrationData.map(d => d.knee.y));
            
            const totalVariance = hipVariance + kneeVariance;
            
            // Very small tolerance for "clean straight leg" but allowing tiny movements
            return totalVariance < CONFIG.STABILITY.CALIBRATION_TOLERANCE;
        }

        function calculateVariance(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const squaredDiffs = values.map(v => Math.pow(v - mean, 2));
            return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / values.length);
        }

        function updateCalibrationTimer(remaining) {
            document.getElementById('cal-timer').textContent = remaining.toFixed(1);
        }

        function drawCalibrationSkeleton(ctx, landmarks, hip, knee, ankle) {
            const idx = state.legIndices;
            
            // Draw selected leg prominently
            const isGood = document.getElementById('cal-status').classList.contains('detected');
            // BLUE for normal detection during calibration
            ctx.strokeStyle = isGood ? '#00ccff' : '#ffcc00';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(hip.x * 1280, hip.y * 720);
            ctx.lineTo(knee.x * 1280, knee.y * 720);
            ctx.lineTo(ankle.x * 1280, ankle.y * 720);
            ctx.stroke();

            // Joints - BLUE for good, YELLOW for error
            ctx.fillStyle = isGood ? '#00ccff' : '#ffcc00';
            [hip, knee, ankle].forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x * 1280, point.y * 720, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            // Angle indicator - WHITE text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px "JetBrains Mono"';
            const geoAngle = calculateAngle(hip, knee, ankle);
            const anaAngle = 180 - geoAngle;
            ctx.fillText(Math.round(anaAngle) + '°', knee.x * 1280 + 20, knee.y * 720);
        }

        // Exercise Logic
        function processExerciseFrame(landmarks) {
            const now = performance.now() / 1000;
            const idx = state.legIndices;

            if (checkTimeout(now)) return;

            const hip = landmarks[idx.hip];
            const knee = landmarks[idx.knee];
            const ankle = landmarks[idx.ankle];

            // Check if tracking is lost
            if (!hip || !knee || !ankle || hip.visibility < 0.5) {
                showCoaching("Leg not visible", "warning");
                return;
            }

            const geoAngle = calculateAngle(hip, knee, ankle);
            const anaAngle = 180 - geoAngle;

            updateSmoothness(geoAngle);
            const smoothScore = getSmoothness();

            // Update hidden metrics
            updateHiddenMetrics(anaAngle, smoothScore);

            // Safety
            if (anaAngle < CONFIG.ROM.MAX_SAFE) {
                state.currentRep.hyperextended = true;
                showCoaching("Don't lock knee", "warning");
            }

            // Phase detection
            if (state.phase === 'STANDING' && anaAngle > CONFIG.ROM.STAND_THRESHOLD) {
                startRep(now, anaAngle, hip.y);
            } else if (state.phase !== 'STANDING') {
                updateRep(anaAngle, geoAngle, hip.y);
                
                if (state.phase === 'ASCENDING' && anaAngle < CONFIG.ROM.STAND_THRESHOLD) {
                    finishRep(now, smoothScore);
                }
            }
        }

        function calculateAngle(a, b, c) {
            const rad = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let ang = Math.abs(rad * 180 / Math.PI);
            return ang > 180 ? 360 - ang : ang;
        }

        function updateSmoothness(angle) {
            const r = state.currentRep;
            const vel = angle - r.lastAngle;
            const jerk = Math.abs(vel - r.lastVelocity);

            r.angleHistory.push({ angle, vel, jerk });
            if (r.angleHistory.length > CONFIG.STABILITY.SMOOTHNESS_WINDOW) {
                r.angleHistory.shift();
            }

            r.maxJerk = Math.max(r.maxJerk, jerk);
            r.lastAngle = angle;
            r.lastVelocity = vel;
        }

        function getSmoothness() {
            const h = state.currentRep.angleHistory;
            if (h.length < 5) return 100;
            const avg = h.reduce((a, b) => a + b.jerk, 0) / h.length;
            return Math.max(0, 100 - avg * 5);
        }

        function startRep(now, angle, hipY) {
            state.phase = 'DESCENDING';
            state.repStartTime = now;
            resetRepData();
            state.currentRep.maxFlexion = angle;
            state.currentRep.startHipY = hipY;
            
            showCoaching("Lower slowly", "info");
        }

        function updateRep(anaAngle, geoAngle, hipY) {
            const r = state.currentRep;
            
            if (anaAngle > r.maxFlexion) {
                r.maxFlexion = anaAngle;
                r.minAngle = geoAngle;
            }

            r.hipVariance = Math.max(r.hipVariance, Math.abs(hipY - r.startHipY));

            if (state.phase === 'DESCENDING' && anaAngle > CONFIG.ROM.DEEP_THRESHOLD) {
                state.phase = 'ASCENDING';
                showCoaching("Extend up", "info");
            }

            // Update timer
            const elapsed = (performance.now() / 1000) - state.repStartTime;
            document.getElementById('metric-timer').textContent = elapsed.toFixed(1) + 's';
        }

        function checkTimeout(now) {
            if (state.phase === 'STANDING') return false;
            
            const elapsed = now - state.repStartTime;
            if (elapsed > CONFIG.TIMEOUT) {
                cancelRep(elapsed);
                return true;
            }
            return false;
        }

        function cancelRep(elapsed) {
            state.phase = 'STANDING';
            state.totalReps++;
            
            logRep({
                num: state.totalReps,
                valid: false,
                rom: 0,
                time: elapsed.toFixed(1),
                score: 0,
                reason: 'Timeout'
            });

            showCoaching("Too slow", "warning");
            updateMetrics();
        }

        function finishRep(now, smoothScore) {
            state.phase = 'STANDING';
            state.totalReps++;

            const r = state.currentRep;
            const duration = now - state.repStartTime;
            const rom = r.maxFlexion;
            const hipStable = r.hipVariance < CONFIG.STABILITY.HIP_THRESHOLD;
            const jerky = r.maxJerk > CONFIG.STABILITY.JERK_THRESHOLD;

            const issues = {
                incompleteROM: rom < 50,
                tooFast: duration < CONFIG.SPEED.MIN_TIME,
                tooSlow: duration > CONFIG.SPEED.MAX_TIME,
                hyperextension: r.hyperextended,
                hipStability: !hipStable,
                jerky: jerky
            };

            const isValid = !issues.incompleteROM && !issues.tooFast && !issues.tooSlow;

            Object.entries(issues).forEach(([k, v]) => { if (v) state.issues[k]++; });

            const score = calculateScore(duration, rom, smoothScore, hipStable, r.hyperextended);

            if (isValid) {
                state.validReps++;
                state.sumRoM += rom;
                state.sumDuration += duration;
                state.totalScore += score;
                if (rom > state.bestROM) state.bestROM = rom;
            }

            logRep({
                num: state.totalReps,
                valid: isValid,
                rom: Math.round(rom),
                time: duration.toFixed(1),
                score: score,
                reason: Object.entries(issues).find(([k, v]) => v)?.[0] || 'Good'
            });

            updateQualityDisplay(score);
            showCoaching(isValid ? "Good rep" : getIssueText(issues), isValid ? "success" : "warning");
            updateMetrics();
        }

        function calculateScore(duration, rom, smooth, hipStable, hyper) {
            let s = 0;
            s += Math.min(100, rom / 70 * 100) * 0.4;
            
            let tempo = duration >= 2.5 && duration <= 4 ? 100 : 
                       duration >= 2 && duration <= 6 ? 70 : 40;
            s += tempo * 0.3;
            
            let ctrl = smooth;
            if (!hipStable) ctrl *= 0.7;
            if (hyper) ctrl *= 0.5;
            s += ctrl * 0.3;
            
            return Math.round(s);
        }

        function getIssueText(issues) {
            if (issues.incompleteROM) return "Bend more";
            if (issues.tooFast) return "Slow down";
            if (issues.tooSlow) return "Speed up";
            if (issues.jerky) return "Control it";
            if (issues.hipStability) return "Stabilize hip";
            if (issues.hyperextension) return "Don't lock";
            return "Check form";
        }

        // UI Updates
        function updateHiddenMetrics(angle, smooth) {
            const angleEl = document.getElementById('metric-angle');
            angleEl.textContent = Math.round(angle) + '°';
            angleEl.className = 'metric-minimal-value ' + 
                (angle < CONFIG.ROM.MAX_SAFE ? 'warning' : 'info');
            
            const smoothEl = document.getElementById('metric-smooth');
            smoothEl.textContent = smooth > 80 ? 'Good' : smooth > 50 ? 'Fair' : 'Poor';
            smoothEl.className = 'metric-minimal-value ' +
                (smooth > 80 ? 'accent' : smooth > 50 ? 'info' : 'warning');
            document.getElementById('metric-smooth-sub').textContent = 'jerk: ' + state.currentRep.maxJerk.toFixed(1);

            const hipVar = state.currentRep.hipVariance;
            const hipEl = document.getElementById('metric-hip');
            hipEl.textContent = hipVar < CONFIG.STABILITY.HIP_THRESHOLD ? 'Stable' : 'Unstable';
            hipEl.className = 'metric-minimal-value ' +
                (hipVar < CONFIG.STABILITY.HIP_THRESHOLD ? 'info' : 'warning');
            document.getElementById('metric-hip-sub').textContent = (hipVar * 100).toFixed(1) + '% var';
        }

        function updateQualityDisplay(score) {
            const el = document.getElementById('metric-quality');
            el.textContent = score;
            el.className = 'metric-minimal-value ' +
                (score > 80 ? 'accent' : score > 60 ? 'info' : 'warning');
        }

        function updateMetrics() {
            document.getElementById('metric-reps').textContent = state.validReps;
            document.getElementById('metric-reps-sub').textContent = `${state.validReps} / ${state.totalReps}`;
        }

        function showCoaching(text, type) {
            const el = document.getElementById('coaching-hud');
            const txt = document.getElementById('coaching-text');
            
            txt.textContent = text;
            
            // Type mapping: success=green, info=blue, warning=yellow
            if (type === 'success') {
                txt.className = 'coaching-text success';
            } else if (type === 'warning') {
                txt.className = 'coaching-text warning';
            } else {
                txt.className = 'coaching-text'; // Default blue/info
            }
            
            el.classList.add('visible');
            
            setTimeout(() => {
                if (txt.textContent === text) el.classList.remove('visible');
            }, 3000);
        }

        function logRep(rep) {
            state.repLogs.unshift(rep);
            renderRepHistory();
        }

        function renderRepHistory() {
            const container = document.getElementById('rep-history');
            
            if (state.repLogs.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No reps yet</div>';
                return;
            }

            container.innerHTML = state.repLogs.slice(0, 10).map(r => `
                <div class="rep-item-compact">
                    <span>#${r.num} ${r.valid ? '✓' : '✗'} ${r.reason}</span>
                    <span style="color: ${r.score > 80 ? 'var(--accent)' : r.score > 60 ? 'var(--info)' : 'var(--warning)'}">${r.score}</span>
                </div>
            `).join('');
        }

        // Toast with types
        function showToast(title, msg, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast';
            
            if (type === 'success') toast.classList.add('success');
            if (type === 'warning') toast.classList.add('warning');
            
            toast.innerHTML = `<div class="toast-title">${title}</div><div class="toast-message">${msg}</div>`;
            
            container.appendChild(toast);
            
            requestAnimationFrame(() => toast.classList.add('visible'));
            
            setTimeout(() => {
                toast.classList.remove('visible');
                setTimeout(() => toast.remove(), 400);
            }, 3000);
        }

        // Drawing - BLUE for detection lines
        function drawSkeleton(ctx, landmarks) {
            const idx = state.legIndices;
            
            // BLUE for normal detection of the leg being tracked
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(landmarks[idx.hip].x * 1280, landmarks[idx.hip].y * 720);
            ctx.lineTo(landmarks[idx.knee].x * 1280, landmarks[idx.knee].y * 720);
            ctx.lineTo(landmarks[idx.ankle].x * 1280, landmarks[idx.ankle].y * 720);
            ctx.stroke();

            // BLUE joints
            ctx.fillStyle = '#00ccff';
            [idx.hip, idx.knee, idx.ankle].forEach(i => {
                ctx.beginPath();
                ctx.arc(landmarks[i].x * 1280, landmarks[i].y * 720, 6, 0, Math.PI * 2);
                ctx.fill();
            });

            // BLUE selection indicator circle
            if (landmarks[idx.knee]) {
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(landmarks[idx.knee].x * 1280, landmarks[idx.knee].y * 720, 40, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Finish & Export
        function finishSession() {
            if (state.validReps === 0) {
                showToast('Error', 'Complete at least one valid rep', 'warning');
                return;
            }

            const avgRom = Math.round(state.sumRoM / state.validReps);
            const avgTime = (state.sumDuration / state.validReps).toFixed(1);
            const avgScore = Math.round(state.totalScore / state.validReps);
            const successRate = Math.round((state.validReps / state.totalReps) * 100);

            currentSessionData = {
                date: new Date().toLocaleString(),
                leg: state.leg.toUpperCase(),
                validReps: state.validReps,
                totalReps: state.totalReps,
                successRate,
                avgRom,
                bestRom: state.bestROM,
                avgTime,
                score: avgScore,
                issues: {...state.issues},
                stabilityWarnings: state.stabilityWarnings
            };

            // Save
            let history = JSON.parse(localStorage.getItem('helify_sessions') || '[]');
            history.unshift(currentSessionData);
            localStorage.setItem('helify_sessions', JSON.stringify(history.slice(0, 10)));

            showModal(currentSessionData);
            resetSession();
            
            // Reset calibration state
            state.isCalibrated = false;
            state.patientId = null;
            document.getElementById('video-frame').classList.remove('has-patient');
            document.getElementById('finish-btn').disabled = true;
            updateStatus('Select leg to start new session');
        }

        function showModal(data) {
            document.getElementById('modal-subtitle').textContent = 
                `${data.date} • ${data.leg} Leg • ${data.totalReps} reps`;

            const body = document.getElementById('modal-body');
            
            let stabilityText = '';
            if (data.stabilityWarnings > 0) {
                stabilityText = `<div class="issue-item" style="color: var(--warning)">
                    <span>Camera Warnings</span>
                    <span>${data.stabilityWarnings}</span>
                </div>`;
            }

            let wrongLegText = '';
            if (data.issues.wrongLeg > 0) {
                wrongLegText = `<div class="issue-item" style="color: var(--warning)">
                    <span>Wrong Leg Detection</span>
                    <span>${data.issues.wrongLeg} times</span>
                </div>`;
            }

            body.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Valid Reps</div>
                        <div class="stat-value accent">${data.validReps}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Success Rate</div>
                        <div class="stat-value ${data.successRate > 70 ? 'accent' : 'info'}">${data.successRate}%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Avg ROM</div>
                        <div class="stat-value info">${data.avgRom}°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Quality Score</div>
                        <div class="stat-value ${data.score > 80 ? 'accent' : data.score > 60 ? 'info' : 'warning'}">${data.score}</div>
                    </div>
                </div>
                
                <div class="issues-section">
                    <div class="issues-title">Issues Detected</div>
                    ${Object.entries(data.issues).filter(([_, v]) => v > 0).map(([k, v]) => `
                        <div class="issue-item">
                            <span>${k.replace(/([A-Z])/g, ' $1').trim()}</span>
                            <span style="color: var(--text-muted)">${v} reps</span>
                        </div>
                    `).join('') || '<div style="color: var(--accent)">No major issues</div>'}
                    ${stabilityText}
                    ${wrongLegText}
                </div>
            `;

            document.getElementById('email-input').value = '';
            document.getElementById('status-text').textContent = '';
            document.getElementById('send-btn').disabled = false;
            document.getElementById('send-btn').textContent = 'Send Report';

            document.getElementById('modal-backdrop').classList.add('visible');
        }

        function closeModal(e) {
            if (e.target === e.currentTarget) {
                document.getElementById('modal-backdrop').classList.remove('visible');
            }
        }

        function closeModalDirect() {
            document.getElementById('modal-backdrop').classList.remove('visible');
        }

        // PDF & Email
        function generatePDF(data) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // Header bar
            doc.setFillColor(0, 255, 157);
            doc.rect(0, 0, 210, 35, 'F');
            
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.text('HELIFY', 20, 25);

            doc.setFontSize(10);
            doc.text(data.date, 150, 15);

            // Content
            doc.setTextColor(80, 80, 80);
            doc.setFontSize(14);
            doc.text('SESSION REPORT', 20, 50);

            let y = 65;
            doc.setFontSize(11);
            
            const add = (label, val) => {
                doc.setFont('helvetica', 'bold');
                doc.text(label + ':', 20, y);
                doc.setFont('helvetica', 'normal');
                doc.text(String(val), 70, y);
                y += 10;
            };

            add('Leg', data.leg);
            add('Valid Reps', `${data.validReps}/${data.totalReps}`);
            add('Success Rate', `${data.successRate}%`);
            add('Average ROM', `${data.avgRom}°`);
            add('Best ROM', `${data.bestRom}°`);
            add('Avg Time', `${data.avgTime}s`);
            add('Quality Score', `${data.score}/100`);

            if (data.stabilityWarnings > 0) {
                y += 5;
                doc.setTextColor(255, 204, 0);
                add('Camera Warnings', `${data.stabilityWarnings}`);
                doc.setTextColor(80, 80, 80);
            }

            if (data.issues.wrongLeg > 0) {
                y += 5;
                doc.setTextColor(255, 204, 0);
                add('Wrong Leg Alerts', `${data.issues.wrongLeg}`);
                doc.setTextColor(80, 80, 80);
            }

            // Footer
            doc.setFillColor(5, 5, 5);
            doc.rect(0, 280, 210, 17, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(9);
            doc.text('Helify Kinetic Rehab System', 105, 291, { align: 'center' });

            return doc;
        }

        function downloadPDF() {
            if (!currentSessionData) return;
            
            try {
                const doc = generatePDF(currentSessionData);
                doc.save(`helify-${Date.now()}.pdf`);
                document.getElementById('status-text').textContent = 'Downloaded';
                document.getElementById('status-text').className = 'status-text success';
            } catch (e) {
                document.getElementById('status-text').textContent = 'Download failed';
                document.getElementById('status-text').className = 'status-text error';
            }
        }

        async function sendEmail() {
            const email = document.getElementById('email-input').value.trim();
            const btn = document.getElementById('send-btn');
            const status = document.getElementById('status-text');

            if (!email || !email.includes('@')) {
                status.textContent = 'Enter valid email';
                status.className = 'status-text error';
                return;
            }

            btn.disabled = true;
            btn.innerHTML = '<span style="display: inline-block; width: 16px; height: 16px; border: 2px solid currentColor; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite;"></span>';
            status.textContent = 'Sending...';
            status.className = 'status-text';

            try {
                const doc = generatePDF(currentSessionData);
                const pdfBase64 = doc.output('datauristring').split(',')[1];

                await emailjs.send(
                    EMAILJS_CONFIG.SERVICE_ID,
                    EMAILJS_CONFIG.TEMPLATE_ID,
                    {
                        to_email: email,
                        from_name: 'Helify',
                        subject: `Helify Report - ${currentSessionData.leg} Leg`,
                        message: `Report attached.\n\n${currentSessionData.validReps} valid reps\n${currentSessionData.successRate}% success\n${currentSessionData.avgRom}° avg ROM\n${currentSessionData.score}/100 quality`,
                        attachment: pdfBase64
                    }
                );

                status.textContent = `Sent to ${email}`;
                status.className = 'status-text success';
                document.getElementById('email-input').value = '';

            } catch (e) {
                console.error(e);
                status.textContent = 'Failed. Try download.';
                status.className = 'status-text error';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Send Report';
            }
        }

        // Start
        init();
    </script>
</body>
</html>
